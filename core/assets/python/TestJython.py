__author__ = 'Jason Lambert'
__email__ = 'jason@jasonlambert.io'
__license__ = 'GPL3'

from com.selfvsmind.carvingcastles.jython import TestJythonType

class TestJython(TestJythonType):
    def say_hello(self):
        print "Hello CarvingCastles"

if __name__ == "__main__":
    test = TestJython()
    test.say_hello()

my_file = open('main.cpp','w')
pythonStringVar = """#include <windows.h>\n#include <GL/gl.h>\n// Removed out-dated un-required WGL header file \n\n#include <math.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\n/* XXX this probably isn't very portable */\n#include <time.h>\n\n#include "teapot.h"\n\n#ifndef M_PI\n#define M_PI 3.14159265\n#endif /* !M_PI */\n\n/* Turn a NULL pointer string into an empty string */\n#define NULLSTR(x) (((x)!=NULL)?(x):(""))\n#define Log(x) { if(verbose) printf x; }\n\n#define Bool int\n#define False 0\n#define True 1\n\n#if 0\n/* wgl extensions */\nPFNWGLSWAPINTERVALEXTPROC wglSwapIntervalEXT = 0;\n#endif\n\n/* Global vars */\nstatic HDC hDC;\nstatic HGLRC hRC;\nstatic HWND hWnd;\nstatic HINSTANCE hInst;\nstatic RECT winrect;\n\nstatic const char *ProgramName;      /* program name (from argv[0]) */\nstatic Bool        verbose = False;  /* verbose output what the program is doing */\n\nstatic GLfloat view_rotx = 20.0, view_roty = 30.0, view_rotz = 0.0;\nstatic GLuint teapot = 0;\nstatic GLfloat angle = 0.0;\n\nstatic\nvoid usage(void)\n{\n   fprintf (stderr, "usage:  %s [options]\\n", ProgramName);\n   fprintf (stderr, "-info\\tPrint additional GL information.\\n");\n   fprintf (stderr, "-h\\tPrint this help page.\\n");\n   fprintf (stderr, "-v\\tVerbose output.\\n");\n   fprintf (stderr, "\\n");\n   exit(EXIT_FAILURE);\n}\n\n\n/* return current time (in seconds) */\nstatic int current_time(void) {\n\t	return (int)time(NULL);\n}\n\nstatic void\ndraw(void)\n{\n   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n   glPushMatrix();\n   glRotatef(view_rotx, 1.0, 0.0, 0.0);\n   glRotatef(view_roty, 0.0, 1.0, 0.0);\n   glRotatef(view_rotz, 0.0, 0.0, 1.0);\n\n   glPushMatrix();\n   glTranslatef(-3.0, -2.0, 0.0);\n   glRotatef(angle, 0.0, 0.0, 1.0);\n   // glCallList(teapot);\n   drawMyCube();\n   glPopMatrix();\n\n   glPushMatrix();\n   glTranslatef(3.1, -2.0, 0.0);\n   glRotatef(-2.0 * angle - 9.0, 0.0, 0.0, 1.0);\n   glCallList(teapot);\n   glPopMatrix();\n\n   glPushMatrix();\n   glTranslatef(-3.1, 4.2, 0.0);\n   glRotatef(-2.0 * angle - 25.0, 0.0, 0.0, 1.0);\n   glCallList(teapot);\n   glPopMatrix();\n\n   glPopMatrix();\n}\n\n\n/* new window size or exposure */\nstatic void\nreshape(int width, int height)\n{\n   GLfloat h = (GLfloat) height / (GLfloat) width;\n\n   glViewport(0, 0, (GLint) width, (GLint) height);\n   glMatrixMode(GL_PROJECTION);\n   glLoadIdentity();\n   glFrustum(-1.0, 1.0, -h, h, 5.0, 60.0);\n   glMatrixMode(GL_MODELVIEW);\n   glLoadIdentity();\n   glTranslatef(0.0, 0.0, -40.0);\n}\n\n\nstatic void\ninit(void)\n{\n   static GLfloat pos[4] = { 5.0, 5.0, 10.0, 0.0 };\n   static GLfloat red[4] = { 0.8, 0.1, 0.0, 1.0 };\n   static GLfloat green[4] = { 0.0, 0.8, 0.2, 1.0 };\n   static GLfloat blue[4] = { 0.2, 0.2, 1.0, 1.0 };\n\n\n   // set up light colors (ambient, diffuse, specular)\n    GLfloat lightKa[] = {.2f, .2f, .2f, 1.0f};  // ambient light\n    GLfloat lightKd[] = {.7f, .7f, .7f, 1.0f};  // diffuse light\n    GLfloat lightKs[] = {1, 1, 1, 1};           // specular light\n    glLightfv(GL_LIGHT0, GL_AMBIENT, lightKa);\n    glLightfv(GL_LIGHT0, GL_DIFFUSE, lightKd);\n    glLightfv(GL_LIGHT0, GL_SPECULAR, lightKs);\n\n    // position the light\n    float lightPos[4] = {0, 0, 20, 1}; // positional light\n    glLightfv(GL_LIGHT0, GL_POSITION, lightPos);\n\n    glEnable(GL_LIGHT0);                        // MUST enable each light source after configuration\n\n    glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);\n    glEnable(GL_COLOR_MATERIAL);\n\n\t	\n   glEnable(GL_CULL_FACE);\n   glEnable(GL_LIGHTING);\n   glEnable(GL_DEPTH_TEST);\n\n   /* make the gears */\n   teapot = createTeapotDL();\n\n   glEnable(GL_NORMALIZE);\n}\n\nLRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {\n\t	switch (uMsg) {\n\t	case WM_CLOSE:\n\t	\t	PostQuitMessage(0);\n\t	\t	return 0;\n\t	case WM_SIZE:\n\t	\t	reshape(LOWORD(lParam), HIWORD(lParam));\n\t	\t	return 0;\n\t	case WM_KEYDOWN:\n\t	\t	if (wParam == VK_LEFT)\n\t	\t	\t	view_roty += 5.0;\n\t	\t	else if (wParam == VK_RIGHT)\n\t	\t	\t	view_roty -= 5.0;\n\t	\t	else if (wParam == VK_UP)\n\t	\t	\t	view_rotx += 5.0;\n\t	\t	else if (wParam == VK_DOWN)\n\t	\t	\t	view_rotx -= 5.0;\n\t	\t	else if (wParam == VK_ESCAPE)\n\t	\t	\t	PostQuitMessage(0);\n\t	\t	return 0;\n\t	}\n\n\t	return DefWindowProc(hWnd, uMsg, wParam, lParam);\n}\n\n/*\n * Create an RGB, double-buffered window.\n * Return the window and context handles.\n */\nstatic void make_window(const char *name, int x, int y, int width, int height) {\n\t	GLuint PixelFormat;\n\t	WNDCLASS wc;\n\t	DWORD dwExStyle, dwStyle;\n\t	static PIXELFORMATDESCRIPTOR pfd = {\n\t	\t	sizeof(PIXELFORMATDESCRIPTOR),\n\t	\t	1,\n\t	\t	PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER,\n\t	\t	PFD_TYPE_RGBA,\n\t	\t	24,\n\t	\t	0, 0, 0, 0, 0, 0,\n\t	\t	0,\n\t	\t	0,\n\t	\t	0,\n\t	\t	0, 0, 0, 0,\n\t	\t	16,\n\t	\t	0,\n\t	\t	0,\n\t	\t	PFD_MAIN_PLANE,\n\t	\t	0,\n\t	\t	0, 0, 0\n\t	};\n\n\t	winrect.left = (long)0;\n\t	winrect.right = (long)width;\n\t	winrect.top = (long) 0;\n\t	winrect.bottom = (long)height;\n\n\t	hInst = GetModuleHandle(NULL);\n\t	wc.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;\n\t	wc.lpfnWndProc = (WNDPROC)WndProc;\n\t	wc.cbClsExtra = 0;\n\t	wc.cbWndExtra = 0;\n\t	wc.hInstance = hInst;\n\t	wc.hIcon = LoadIcon(NULL, IDI_WINLOGO);\n\t	wc.hCursor = LoadCursor(NULL, IDC_ARROW);\n\t	wc.hbrBackground = NULL;\n\t	wc.lpszMenuName = NULL;\n\t	wc.lpszClassName = name;\n\t	if (!RegisterClass(&wc)) {\n\t	\t	printf("failed to register class\\n");\n\t	\t	exit(0);\n\t	}\n\n\t	dwExStyle = WS_EX_APPWINDOW | WS_EX_WINDOWEDGE;\n\t	dwStyle = WS_OVERLAPPEDWINDOW;\n\t	AdjustWindowRectEx(&winrect, dwStyle, False, dwExStyle);\n\n\t	if (!(hWnd = CreateWindowEx(dwExStyle, name, name,\n\t	\t	WS_CLIPSIBLINGS | WS_CLIPCHILDREN | dwStyle, 0, 0,\n\t	\t	winrect.right - winrect.left, winrect.bottom - winrect.top,\n\t	\t	NULL, NULL, hInst, NULL))) {\n\t	\t	printf("failed to create window\\n");\n\t	\t	exit(0);\n\t	}\n\n\t	if (!(hDC = GetDC(hWnd)) ||\n\t	\t	!(PixelFormat = ChoosePixelFormat(hDC, &pfd)) ||\n\t	\t	!(SetPixelFormat(hDC, PixelFormat, &pfd)) ||\n\t	\t	!(hRC = wglCreateContext(hDC)) ||\n\t	\t	!(wglMakeCurrent(hDC, hRC))) {\n\t	\t	printf("failed to initialise opengl\\n");\n\t	\t	exit(0);\n\t	}\n\n\t	ShowWindow(hWnd, SW_SHOW);\n\t	SetForegroundWindow(hWnd);\n\t	SetFocus(hWnd);\n}\n\n\nstatic void event_loop() {\n\t	MSG msg;\n\t	int t, t0 = current_time();\n\t	int frames = 0;\n\n\t	while(1) {\n\t	\t	if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {\n\t	\t	\t	if (msg.message == WM_QUIT) break;;\n\t	\t	\t	TranslateMessage(&msg);\n\t	\t	\t	DispatchMessage(&msg);\n\t	\t	}\n\n\t	\t	angle += 0.02;\n\t	\t	draw();\n\t	\t	SwapBuffers(hDC);\n\n\t	\t	/* calc framerate */\n\t	\t	t = current_time();\n\t	\t	frames++;\n\t	\t	if (t - t0 >= 5.0) {\n\t	\t	\t	GLfloat s = t - t0;\n\t	\t	\t	GLfloat fps = frames / s;\n\t	\t	\t	printf("%d frames in %3.1f seconds = %6.3f FPS\\n", frames, s, fps);\n\t	 \t	\t	t0 = t;\n\t	\t	\t	frames = 0;\n\t	\t	}\n\t	}\n}\n\nint\nmain(int argc, char *argv[])\n{\n   int            i;\n   Bool\t	printInfo = False;\n\n   ProgramName = argv[0];\n\n   for (i = 1; i < argc; i++) {\n      const char *arg = argv[i];\n      int         len = strlen(arg);\n\n      if (strcmp(argv[i], "-info") == 0) {\n         printInfo = GL_TRUE;\n      }\n      else if (!strncmp("-v", arg, len)) {\n         verbose   = True;\n         printInfo = GL_TRUE;\n      }\n      else if (strcmp(argv[i], "-h") == 0) {\n         usage();\n      }\n      else\n      {\n        fprintf(stderr, "%s: Unsupported option '%s'.\\n", ProgramName, argv[i]);\n        usage();\n      }\n   }\n\n\n\t	make_window("moving to PHOENIX!!", 0, 0, 300, 300);\n\t	reshape(300, 300);\n\n/* force vsync off */\n#if 0\n\t	wglSwapIntervalEXT = wglGetProcAddress("wglSwapIntervalEXT");\n\t	if (!wglSwapIntervalEXT) {\n\t	\t	printf("warning: wglSwapIntervalEXT missing, cannot force vsync off\\n");\n\t	} else if (!wglSwapIntervalEXT(0)) {\n\t	\t	printf("warning: failed to force vsync off, it may still be on\\n");\n\t	}\n#endif\n\t	\n   if (printInfo) {\n      printf("GL_RENDERER   = %s\\n", (char *) glGetString(GL_RENDERER));\n      printf("GL_VERSION    = %s\\n", (char *) glGetString(GL_VERSION));\n      printf("GL_VENDOR     = %s\\n", (char *) glGetString(GL_VENDOR));\n      printf("GL_EXTENSIONS = %s\\n", (char *) glGetString(GL_EXTENSIONS));\n   }\n\n   init();\n\n   event_loop();\n\n/* cleanup */\n\t	wglMakeCurrent (NULL, NULL);\n\t	wglDeleteContext (hRC);\n\t	ReleaseDC (hWnd, hDC);\n\n\n\n\t	return EXIT_SUCCESS;\n}"""
my_file.write(pythonStringVar)
my_file.close()

